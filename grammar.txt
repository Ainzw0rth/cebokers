# Javascript syntax grammar parser
# (c) Cebokers 2022

# Every line started with '#' and empty line will not be processed by the parser

# -------- GENERAL STATEMENT --------
GENERAL_STMT -> CONDITIONAL_STMT | LOOP_STMT | FUNCTION_STMT | DEFS_STMT | COMMENT_STMT | TRY_CATCH | THROW
GENERAL_STMT -> GENERAL_STMT ENTER

# -------- START --------
START -> GENERAL_STMT

# -------- DELETE STATEMENT --------
DELETE_STMT -> DELETE OBJECT

# -------- CONDITIONAL STATEMENT --------
CONDITIONAL_STMT -> SWITCH_STMT
CONDITIONAL_STMT -> IF_STMT 
CONDITIONAL_BODY -> GENERAL_STMT
CONDITIONAL_BODY -> CONDITIONAL_BODY ENTER 
CONDITIONAL_BODY -> CONDITIONAL_BODY ENTER CONDITIONAL_BODY

# . SWITCH STATEMENT
SWITCH_STMT -> SWITCH ( EXPRESSION ) E_ENTER { E_ENTER CASE_STMT E_ENTER }
CASE_STMT -> CASE INT : ENTER EXPRESSION BREAK | CASE INT : ENTER CONDITIONAL_STMT BREAK | CASE INT : ENTER LOOP_STMT BREAK  | DEFAULT : ENTER EXPRESSION | DEFAULT : ENTER CONDITIONAL_STMT | DEFAULT : ENTER LOOP_STMT | EPSILON
CASE_STMT -> CASE INT : ENTER EXPRESSION BREAK ENTER CASE_STMT | CASE INT : ENTER CONDITIONAL_STMT BREAK ENTER CASE_STMT | CASE INT : ENTER LOOP_STMT BREAK ENTER CASE_STMT

# . IF ELSEIF ELSE
IF_STMT -> IF EXPRESSION
IF_STMT -> IF EXPRESSION E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER } IF_PART_A | IF EXPRESSION IF_STMT E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER }
IF_PART_A -> ELIF E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER }
IF_PART_A -> ELIF E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER } IF_PART_A | IF_PART_B E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER }
IF_PART_B -> ELSE E_ENTER { E_ENTER CONDITIONAL_BODY E_ENTER }

# -------- LOOP --------
LOOP_STMT -> DO_WHILE | WHILE | FOR | FOR_IN | FOR_OF | FOR_AWAIT_OF 
LOOP_BODY -> GENERAL_STMT | BREAK | CONTINUE
LOOP_BODY -> LOOP_BODY ENTER LOOP_BODY
LOOP_BODY -> LOOP_BODY ENTER
# IF_LOOP_BODY (outliers: ketika break/continue berada di dalam if)

# . DO WHILE
DO_WHILE -> DO E_ENTER LOOP_BODY ENTER WHILE EXPRESSION ENTER
DO_WHILE -> DO E_ENTER { E_ENTER LOOP_BODY E_ENTER } WHILE ( EXPRESSION )

# . FOR
FOR -> FOR ( DEFS ; DATA ; DATA ) E_ENTER LOOP_BODY ENTER
FOR -> FOR ( DEFS ; DATA ; DATA ) E_ENTER { E_ENTER LOOP_BODY E_ENTER }

# . FOR IN
FOR_IN -> FOR ( VAR_NAME IN OBJECT ) E_ENTER LOOP_BODY ENTER
FOR_IN -> FOR ( VAR_NAME IN OBJECT ) E_ENTER { E_ENTER LOOP_BODY E_ENTER }

# . FOR OF
FOR_OF -> FOR ( VAR_NAME OF OBJECT ) E_ENTER LOOP_BODY ENTER
FOR_OF -> FOR ( VAR_NAME OF OBJECT ) { E_ENTER LOOP_BODY E_ENTER }

# . FOR AWAIT ... OF
FOR_AWAIT_OF -> FOR AWAIT ( VAR_NAME OF OBJECT ) E_ENTER LOOP_BODY ENTER
FOR_AWAIT_OF -> FOR AWAIT ( VAR_NAME OF OBJECT ) E_ENTER { E_ENTER LOOP_BODY }

# . WHILE
WHILE -> WHILE ( EXPRESSION ) E_ENTER LOOP_BODY
WHILE -> WHILE ( EXPRESSION ) E_ENTER { E_ENTER LOOP_BODY }

# -------- DEFS --------
# . FUNCTION
FUNCTION_STMT -> FUNCTION | ASYNC_FUNCTION | FUNCTION_CALL

FUNCTION_BODY -> GENERAL_STMT | RETURN
FUNCTION_BODY -> FUNCTION_BODY ENTER FUNCTION_BODY
FUNCTION_BODY_ASYNC -> FUNCTION_BODY | AWAIT FUNCTION_BODY

FUNCTION -> FUNCTION FUNCTION_NAME ( PARAMS ) E_ENTER FUNCTION_BODY ENTER
FUNCTION -> FUNCTION FUNCTION_NAME ( PARAMS ) E_ENTER { E_ENTER FUNCTION_BODY E_ENTER }
ASYNC_FUNCTION -> ASYNC FUNCTION FUNCTION_NAME ( PARAMS ) E_ENTER FUNCTION_BODY_ASYNC ENTER
PARAMS -> VAR_NAME | VAR_NAME , PARAMS
PARAMS -> VAR_NAME = DATA | VAR_NAME = DATA , PARAMS
FUNCTION_NAME -> VAR_NAME
FUNCTION_CALL -> FUNCTION_NAME ( ARGS ) ENTER
ARGS -> DATA | DATA , ARGS
ARGS -> VAR_NAME = DATA | VAR_NAME = DATA , ARGS
RETURN -> RETURN DATA E_ENTER

# . VARIABLES
DEFS_STMT -> VAR | LET | CONST | DEFS

DEFS -> VAR_NAME = DATA | VAR_NAME = DATA , DEFS
DEFS -> VAR_NAME | VAR_NAME , DEFS
DEFS -> VAR_NAME = DATA | VAR_NAME = DATA , DEFS
LET -> LET DEFS
CONST -> CONST DEFS
VAR -> VAR DEFS

# -------- TRY CATCH -------- (finally also included)
TRY_CATCH -> TRY E_ENTER { E_ENTER GENERAL_STMT E_ENTER } E_ENTER CATCH E_ENTER ( VAR_NAME ) E_ENTER { E_ENTER GENERAL_STMT E_ENTER }
TRY_CATCH -> TRY E_ENTER { E_ENTER GENERAL_STMT E_ENTER } E_ENTER FINALLY E_ENTER { E_ENTER GENERAL_STMT E_ENTER }
TRY_CATCH -> TRY E_ENTER { E_ENTER GENERAL_STMT E_ENTER } E_ENTER CATCH E_ENTER ( VAR_NAME ) E_ENTER { E_ENTER GENERAL_STMT E_ENTER } E_ENTER FINALLY E_ENTER { E_ENTER GENERAL_STMT E_ENTER }

# -------- THROW --------
THROW -> THROW VAR_NAME
THROW -> THROW DATA
THROW -> THROW FUNCTION

# ------- DATA TYPES -------
DATA -> STRING | NUMBER | BOOLEAN | NULL | OBJECT | ARRAY | FUNCTION_CALL | VAR_NAME | EXPRESSION
NUMBER -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | NUMBER NUMBER
NUMBER -> NUMBER . NUMBER
STRING -> " STRING "
STRING -> ' STRING '
STRING -> ` STRING `
BOOLEAN -> TRUE | FALSE

# . OBJECT
OBJECT -> { E_ENTER OBJECT_BODY E_ENTER }
OBJECT_BODY -> VAR_NAME : DATA_TYPES | VAR_NAME : DATA_TYPES , OBJECT_BODY

# . ARRAY
ARRAY -> [ E_ENTER ARRAY_BODY E_ENTER ]
ARRAY_BODY -> DATA_TYPES | DATA_TYPES , ARRAY_BODY

# -------- ENTER --------
ENTER -> ENTER ENTER

# . E-Enter (epsilon or enter)
E_ENTER -> EPSILON
E_ENTER -> ENTER

# -------- COMMENTS --------
COMMENT_STMT -> SINGLE_LINE_COMMENT | MULTI_LINE_COMMENT
SINGLE_LINE_COMMENT -> // COMMENT
MULTI_LINE_COMMENT -> /* COMMENT */

@